{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useState, useEffect } from 'react';\n/**\n * Use CurrentLocation across the app to get users current location.\n * Becareful not to get location to often, . so probably will refactor\n * this to have latest location, mix that with watch location\n * @param {*} options\n */\n\nexport const useCurrentLocation = (options = {}) => {\n  _s();\n\n  const [locationError, setLocationError] = useState(null);\n\n  const handleSuccess = position => {\n    const {\n      latitude,\n      longitude\n    } = position.coords;\n    setLocation({\n      lat: latitude,\n      lng: longitude\n    });\n    const loc = {\n      lat: latitude,\n      lng: longitude\n    };\n    localStorage.setItem('currentLocation', JSON.stringify(loc));\n  };\n\n  useEffect(() => {\n    const currentLocation = localStorage.getItem('currentLocation');\n\n    if (!currentLocation) {\n      if (!navigator.geolocation) {\n        setLocationError('GeoLocation not available from browser');\n        return;\n      }\n\n      navigator.geolocation.getCurrentPosition(handleSuccess, handleError, options);\n      return function cleanup() {\n        console.log('Just demonstrating where any clean would happen for an effect in react. This function will run after each rerender ');\n      };\n    } else {\n      const loc = JSON.parse(currentLocation);\n      setLocation({\n        lat: loc.lat,\n        lng: loc.lng\n      });\n    }\n  }, [options]);\n  const [location, setLocation] = useState(null);\n\n  const handleError = error => {\n    setLocationError(error.message);\n  };\n\n  return {\n    location,\n    locationError\n  };\n};\n\n_s(useCurrentLocation, \"HQmDzKUg9v1qQIxr/MlBFmZJFGo=\");","map":{"version":3,"sources":["/Users/samuelsegal/git/gigety/gigety-reactjs/react-gigety/src/hooks/useCurrentLocation.js"],"names":["useState","useEffect","useCurrentLocation","options","locationError","setLocationError","handleSuccess","position","latitude","longitude","coords","setLocation","lat","lng","loc","localStorage","setItem","JSON","stringify","currentLocation","getItem","navigator","geolocation","getCurrentPosition","handleError","cleanup","console","log","parse","location","error","message"],"mappings":";;AAAA,SAASA,QAAT,EAAmBC,SAAnB,QAAoC,OAApC;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,kBAAkB,GAAG,CAACC,OAAO,GAAG,EAAX,KAAkB;AAAA;;AACnD,QAAM,CAACC,aAAD,EAAgBC,gBAAhB,IAAoCL,QAAQ,CAAC,IAAD,CAAlD;;AACA,QAAMM,aAAa,GAAIC,QAAD,IAAc;AACnC,UAAM;AAAEC,MAAAA,QAAF;AAAYC,MAAAA;AAAZ,QAA0BF,QAAQ,CAACG,MAAzC;AACAC,IAAAA,WAAW,CAAC;AAAEC,MAAAA,GAAG,EAAEJ,QAAP;AAAiBK,MAAAA,GAAG,EAAEJ;AAAtB,KAAD,CAAX;AACA,UAAMK,GAAG,GAAG;AACXF,MAAAA,GAAG,EAAEJ,QADM;AAEXK,MAAAA,GAAG,EAAEJ;AAFM,KAAZ;AAIAM,IAAAA,YAAY,CAACC,OAAb,CAAqB,iBAArB,EAAwCC,IAAI,CAACC,SAAL,CAAeJ,GAAf,CAAxC;AACA,GARD;;AASAb,EAAAA,SAAS,CAAC,MAAM;AACf,UAAMkB,eAAe,GAAGJ,YAAY,CAACK,OAAb,CAAqB,iBAArB,CAAxB;;AACA,QAAI,CAACD,eAAL,EAAsB;AACrB,UAAI,CAACE,SAAS,CAACC,WAAf,EAA4B;AAC3BjB,QAAAA,gBAAgB,CAAC,wCAAD,CAAhB;AACA;AACA;;AACDgB,MAAAA,SAAS,CAACC,WAAV,CAAsBC,kBAAtB,CAAyCjB,aAAzC,EAAwDkB,WAAxD,EAAqErB,OAArE;AACA,aAAO,SAASsB,OAAT,GAAmB;AACzBC,QAAAA,OAAO,CAACC,GAAR,CACC,qHADD;AAGA,OAJD;AAKA,KAXD,MAWO;AACN,YAAMb,GAAG,GAAGG,IAAI,CAACW,KAAL,CAAWT,eAAX,CAAZ;AACAR,MAAAA,WAAW,CAAC;AAAEC,QAAAA,GAAG,EAAEE,GAAG,CAACF,GAAX;AAAgBC,QAAAA,GAAG,EAAEC,GAAG,CAACD;AAAzB,OAAD,CAAX;AACA;AACD,GAjBQ,EAiBN,CAACV,OAAD,CAjBM,CAAT;AAkBA,QAAM,CAAC0B,QAAD,EAAWlB,WAAX,IAA0BX,QAAQ,CAAC,IAAD,CAAxC;;AAEA,QAAMwB,WAAW,GAAIM,KAAD,IAAW;AAC9BzB,IAAAA,gBAAgB,CAACyB,KAAK,CAACC,OAAP,CAAhB;AACA,GAFD;;AAIA,SAAO;AAAEF,IAAAA,QAAF;AAAYzB,IAAAA;AAAZ,GAAP;AACA,CApCM;;GAAMF,kB","sourcesContent":["import { useState, useEffect } from 'react';\n/**\n * Use CurrentLocation across the app to get users current location.\n * Becareful not to get location to often, . so probably will refactor\n * this to have latest location, mix that with watch location\n * @param {*} options\n */\nexport const useCurrentLocation = (options = {}) => {\n\tconst [locationError, setLocationError] = useState(null);\n\tconst handleSuccess = (position) => {\n\t\tconst { latitude, longitude } = position.coords;\n\t\tsetLocation({ lat: latitude, lng: longitude });\n\t\tconst loc = {\n\t\t\tlat: latitude,\n\t\t\tlng: longitude,\n\t\t};\n\t\tlocalStorage.setItem('currentLocation', JSON.stringify(loc));\n\t};\n\tuseEffect(() => {\n\t\tconst currentLocation = localStorage.getItem('currentLocation');\n\t\tif (!currentLocation) {\n\t\t\tif (!navigator.geolocation) {\n\t\t\t\tsetLocationError('GeoLocation not available from browser');\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnavigator.geolocation.getCurrentPosition(handleSuccess, handleError, options);\n\t\t\treturn function cleanup() {\n\t\t\t\tconsole.log(\n\t\t\t\t\t'Just demonstrating where any clean would happen for an effect in react. This function will run after each rerender '\n\t\t\t\t);\n\t\t\t};\n\t\t} else {\n\t\t\tconst loc = JSON.parse(currentLocation);\n\t\t\tsetLocation({ lat: loc.lat, lng: loc.lng });\n\t\t}\n\t}, [options]);\n\tconst [location, setLocation] = useState(null);\n\n\tconst handleError = (error) => {\n\t\tsetLocationError(error.message);\n\t};\n\n\treturn { location, locationError };\n};\n"]},"metadata":{},"sourceType":"module"}