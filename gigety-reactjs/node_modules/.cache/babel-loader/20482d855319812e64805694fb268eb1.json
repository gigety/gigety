{"ast":null,"code":"import { GET_ERRORS, GET_CURRENT_USR, GET_CURRENT_USR_ACCOUNT } from './types';\nimport gigety from 'apis/gigety';\nimport { setJwtTokenHeader } from 'utils/jwtUtil';\nexport const getCurrentUser = () => async dispatch => {\n  try {\n    const response = await gigety.get('/user/me');\n    dispatch({\n      type: GET_CURRENT_USR,\n      payload: response.data\n    });\n  } catch (error) {\n    console.error('Error getting user info from /user/me :: ', error);\n    localStorage.removeItem('jwtToken');\n    setJwtTokenHeader(false);\n    dispatch({\n      type: GET_ERRORS,\n      payload: error\n    });\n  }\n};\nexport const getUserAccount = () => async dispatch => {\n  try {\n    const response = await gigety.get('/userAccount');\n    dispatch({\n      type: GET_CURRENT_USR_ACCOUNT,\n      payload: response.data\n    });\n  } catch (error) {\n    console.error('ERROR :: ', error);\n    dispatch({\n      type: GET_ERRORS,\n      payload: error\n    });\n  }\n};\nexport const updateUserAccount = gigUserAccount => async dispatch => {\n  try {\n    console.log('fuuuuuuuuuu :: ', gigUserAccount);\n    const response = await gigety.post('/userAccount/update', JSON.parse(gigUserAccount));\n    console.log('responinnnnnse ::', response.data);\n    dispatch({\n      type: GET_CURRENT_USR_ACCOUNT,\n      payload: response.data\n    });\n  } catch (error) {\n    console.error('ERROR :: ', error);\n    dispatch({\n      type: GET_ERRORS,\n      payload: error\n    });\n  }\n};","map":{"version":3,"sources":["/Users/samuelsegal/git/gigety/gigety-reactjs/react-gigety/src/redux/actions/gigUserAction.js"],"names":["GET_ERRORS","GET_CURRENT_USR","GET_CURRENT_USR_ACCOUNT","gigety","setJwtTokenHeader","getCurrentUser","dispatch","response","get","type","payload","data","error","console","localStorage","removeItem","getUserAccount","updateUserAccount","gigUserAccount","log","post","JSON","parse"],"mappings":"AAAA,SAASA,UAAT,EAAqBC,eAArB,EAAsCC,uBAAtC,QAAqE,SAArE;AACA,OAAOC,MAAP,MAAmB,aAAnB;AACA,SAASC,iBAAT,QAAkC,eAAlC;AACA,OAAO,MAAMC,cAAc,GAAG,MAAM,MAAOC,QAAP,IAAoB;AACvD,MAAI;AACH,UAAMC,QAAQ,GAAG,MAAMJ,MAAM,CAACK,GAAP,CAAW,UAAX,CAAvB;AACAF,IAAAA,QAAQ,CAAC;AACRG,MAAAA,IAAI,EAAER,eADE;AAERS,MAAAA,OAAO,EAAEH,QAAQ,CAACI;AAFV,KAAD,CAAR;AAIA,GAND,CAME,OAAOC,KAAP,EAAc;AACfC,IAAAA,OAAO,CAACD,KAAR,CAAc,2CAAd,EAA2DA,KAA3D;AACAE,IAAAA,YAAY,CAACC,UAAb,CAAwB,UAAxB;AACAX,IAAAA,iBAAiB,CAAC,KAAD,CAAjB;AACAE,IAAAA,QAAQ,CAAC;AACRG,MAAAA,IAAI,EAAET,UADE;AAERU,MAAAA,OAAO,EAAEE;AAFD,KAAD,CAAR;AAIA;AACD,CAhBM;AAiBP,OAAO,MAAMI,cAAc,GAAG,MAAM,MAAOV,QAAP,IAAoB;AACvD,MAAI;AACH,UAAMC,QAAQ,GAAG,MAAMJ,MAAM,CAACK,GAAP,CAAW,cAAX,CAAvB;AACAF,IAAAA,QAAQ,CAAC;AACRG,MAAAA,IAAI,EAAEP,uBADE;AAERQ,MAAAA,OAAO,EAAEH,QAAQ,CAACI;AAFV,KAAD,CAAR;AAIA,GAND,CAME,OAAOC,KAAP,EAAc;AACfC,IAAAA,OAAO,CAACD,KAAR,CAAc,WAAd,EAA2BA,KAA3B;AACAN,IAAAA,QAAQ,CAAC;AACRG,MAAAA,IAAI,EAAET,UADE;AAERU,MAAAA,OAAO,EAAEE;AAFD,KAAD,CAAR;AAIA;AACD,CAdM;AAgBP,OAAO,MAAMK,iBAAiB,GAAIC,cAAD,IAAoB,MAAOZ,QAAP,IAAoB;AACxE,MAAI;AACHO,IAAAA,OAAO,CAACM,GAAR,CAAY,iBAAZ,EAA+BD,cAA/B;AACA,UAAMX,QAAQ,GAAG,MAAMJ,MAAM,CAACiB,IAAP,CAAY,qBAAZ,EAAmCC,IAAI,CAACC,KAAL,CAAWJ,cAAX,CAAnC,CAAvB;AACAL,IAAAA,OAAO,CAACM,GAAR,CAAY,mBAAZ,EAAiCZ,QAAQ,CAACI,IAA1C;AACAL,IAAAA,QAAQ,CAAC;AACRG,MAAAA,IAAI,EAAEP,uBADE;AAERQ,MAAAA,OAAO,EAAEH,QAAQ,CAACI;AAFV,KAAD,CAAR;AAIA,GARD,CAQE,OAAOC,KAAP,EAAc;AACfC,IAAAA,OAAO,CAACD,KAAR,CAAc,WAAd,EAA2BA,KAA3B;AACAN,IAAAA,QAAQ,CAAC;AACRG,MAAAA,IAAI,EAAET,UADE;AAERU,MAAAA,OAAO,EAAEE;AAFD,KAAD,CAAR;AAIA;AACD,CAhBM","sourcesContent":["import { GET_ERRORS, GET_CURRENT_USR, GET_CURRENT_USR_ACCOUNT } from './types';\nimport gigety from 'apis/gigety';\nimport { setJwtTokenHeader } from 'utils/jwtUtil';\nexport const getCurrentUser = () => async (dispatch) => {\n\ttry {\n\t\tconst response = await gigety.get('/user/me');\n\t\tdispatch({\n\t\t\ttype: GET_CURRENT_USR,\n\t\t\tpayload: response.data,\n\t\t});\n\t} catch (error) {\n\t\tconsole.error('Error getting user info from /user/me :: ', error);\n\t\tlocalStorage.removeItem('jwtToken');\n\t\tsetJwtTokenHeader(false);\n\t\tdispatch({\n\t\t\ttype: GET_ERRORS,\n\t\t\tpayload: error,\n\t\t});\n\t}\n};\nexport const getUserAccount = () => async (dispatch) => {\n\ttry {\n\t\tconst response = await gigety.get('/userAccount');\n\t\tdispatch({\n\t\t\ttype: GET_CURRENT_USR_ACCOUNT,\n\t\t\tpayload: response.data,\n\t\t});\n\t} catch (error) {\n\t\tconsole.error('ERROR :: ', error);\n\t\tdispatch({\n\t\t\ttype: GET_ERRORS,\n\t\t\tpayload: error,\n\t\t});\n\t}\n};\n\nexport const updateUserAccount = (gigUserAccount) => async (dispatch) => {\n\ttry {\n\t\tconsole.log('fuuuuuuuuuu :: ', gigUserAccount);\n\t\tconst response = await gigety.post('/userAccount/update', JSON.parse(gigUserAccount));\n\t\tconsole.log('responinnnnnse ::', response.data);\n\t\tdispatch({\n\t\t\ttype: GET_CURRENT_USR_ACCOUNT,\n\t\t\tpayload: response.data,\n\t\t});\n\t} catch (error) {\n\t\tconsole.error('ERROR :: ', error);\n\t\tdispatch({\n\t\t\ttype: GET_ERRORS,\n\t\t\tpayload: error,\n\t\t});\n\t}\n};\n"]},"metadata":{},"sourceType":"module"}