{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { BehaviorSubject, Observable, Subject } from 'rxjs';\nimport { filter, share, take } from 'rxjs/operators';\nimport { Client } from '@stomp/stompjs';\nimport { RxStompState } from './rx-stomp-state';\n/**\n * This is the main Stomp Client.\n * Typically you will create an instance of this to connect to the STOMP broker.\n *\n * This wraps [@stomp/stompjs]{@link https://github.com/stomp-js/stompjs}\n * {@link Client} class.\n *\n * The key difference is that it exposes operations as RxJS Observables.\n * For example when a STOMP endpoint is subscribed it returns an Observable\n * that will stream all received messages.\n *\n * With exception of beforeConnect, functionality related to all callbacks in\n * [@stomp/stompjs Client]{@link Client}\n * is exposed as Observables/Subjects/BehaviorSubjects.\n *\n * RxStomp also tries to transparently handle connection failures.\n *\n * Part of `@stomp/rx-stomp`\n */\n\nexport class RxStomp {\n  /**\n   * Constructor\n   */\n  constructor() {\n    /**\n     * Internal array to hold locally queued messages when STOMP broker is not connected.\n     */\n    this._queuedMessages = [];\n    this._stompClient = new Client();\n\n    const noOp = () => {}; // Before connect is no op by default\n\n\n    this._beforeConnect = noOp; // debug is no-op by default\n\n    this._debug = noOp; // Initial state is CLOSED\n\n    this._connectionStatePre$ = new BehaviorSubject(RxStompState.CLOSED);\n    this._connectedPre$ = this._connectionStatePre$.pipe(filter(currentState => {\n      return currentState === RxStompState.OPEN;\n    })); // Initial state is CLOSED\n\n    this.connectionState$ = new BehaviorSubject(RxStompState.CLOSED);\n    this.connected$ = this.connectionState$.pipe(filter(currentState => {\n      return currentState === RxStompState.OPEN;\n    })); // Setup sending queuedMessages\n\n    this.connected$.subscribe(() => {\n      this._sendQueuedMessages();\n    });\n    this._serverHeadersBehaviourSubject$ = new BehaviorSubject(null);\n    this.serverHeaders$ = this._serverHeadersBehaviourSubject$.pipe(filter(headers => {\n      return headers !== null;\n    }));\n    this.stompErrors$ = new Subject();\n    this.unhandledMessage$ = new Subject();\n    this.unhandledReceipts$ = new Subject();\n    this.unhandledFrame$ = new Subject();\n    this.webSocketErrors$ = new Subject();\n  }\n  /**\n   * Instance of actual\n   * [@stomp/stompjs]{@link https://github.com/stomp-js/stompjs}\n   * {@link Client}.\n   *\n   * **Be careful in calling methods on it directly - you may get unintended consequences.**\n   */\n\n\n  get stompClient() {\n    return this._stompClient;\n  }\n  /**\n   * Set configuration. This method may be called multiple times.\n   * Each call will add to the existing configuration.\n   *\n   * Example:\n   *\n   * ```javascript\n   *        const rxStomp = new RxStomp();\n   *        rxStomp.configure({\n   *          brokerURL: 'ws://127.0.0.1:15674/ws',\n   *          connectHeaders: {\n   *            login: 'guest',\n   *            passcode: 'guest'\n   *          },\n   *          heartbeatIncoming: 0,\n   *          heartbeatOutgoing: 20000,\n   *          reconnectDelay: 200,\n   *          debug: (msg: string): void => {\n   *            console.log(new Date(), msg);\n   *          }\n   *        });\n   *        rxStomp.activate();\n   * ```\n   *\n   * Maps to: [Client#configure]{@link Client#configure}\n   */\n\n\n  configure(rxStompConfig) {\n    const stompConfig = Object.assign({}, rxStompConfig);\n\n    if (stompConfig.beforeConnect) {\n      this._beforeConnect = stompConfig.beforeConnect;\n      delete stompConfig.beforeConnect;\n    } // RxStompConfig has subset of StompConfig fields\n\n\n    this._stompClient.configure(stompConfig);\n\n    if (stompConfig.debug) {\n      this._debug = stompConfig.debug;\n    }\n  }\n  /**\n   * Initiate the connection with the broker.\n   * If the connection breaks, as per [RxStompConfig#reconnectDelay]{@link RxStompConfig#reconnectDelay},\n   * it will keep trying to reconnect.\n   *\n   * Call [RxStomp#deactivate]{@link RxStomp#deactivate} to disconnect and stop reconnection attempts.\n   *\n   * Maps to: [Client#activate]{@link Client#activate}\n   */\n\n\n  activate() {\n    this._stompClient.configure({\n      beforeConnect: () => __awaiter(this, void 0, void 0, function* () {\n        this._changeState(RxStompState.CONNECTING); // Call handler\n\n\n        yield this._beforeConnect(this);\n      }),\n      onConnect: frame => {\n        this._serverHeadersBehaviourSubject$.next(frame.headers); // Indicate our connected state to observers\n\n\n        this._changeState(RxStompState.OPEN);\n      },\n      onStompError: frame => {\n        // Trigger the frame subject\n        this.stompErrors$.next(frame);\n      },\n      onWebSocketClose: () => {\n        this._changeState(RxStompState.CLOSED);\n      },\n      onUnhandledMessage: message => {\n        this.unhandledMessage$.next(message);\n      },\n      onUnhandledReceipt: frame => {\n        this.unhandledReceipts$.next(frame);\n      },\n      onUnhandledFrame: frame => {\n        this.unhandledFrame$.next(frame);\n      },\n      onWebSocketError: evt => {\n        this.webSocketErrors$.next(evt);\n      }\n    }); // Attempt connection\n\n\n    this._stompClient.activate();\n  }\n  /**\n   * Disconnect if connected and stop auto reconnect loop.\n   * Appropriate callbacks will be invoked if underlying STOMP connection was connected.\n   *\n   * To reactivate you can call [RxStomp#activate]{@link RxStomp#activate}.\n   *\n   * Maps to: [Client#deactivate]{@link Client#deactivate}\n   */\n\n\n  deactivate() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this._changeState(RxStompState.CLOSING); // The promise will be resolved immediately if there are no active connection\n      // otherwise, after it has successfully disconnected.\n\n\n      yield this._stompClient.deactivate();\n\n      this._changeState(RxStompState.CLOSED);\n    });\n  }\n  /**\n   * It will return `true` if STOMP broker is connected and `false` otherwise.\n   */\n\n\n  connected() {\n    return this.connectionState$.getValue() === RxStompState.OPEN;\n  }\n  /**\n   * If the client is active (connected or going to reconnect).\n   *\n   *  Maps to: [Client#active]{@link Client#active}\n   */\n\n\n  get active() {\n    return this.stompClient.active;\n  }\n  /**\n   * Send a message to a named destination. Refer to your STOMP broker documentation for types\n   * and naming of destinations.\n   *\n   * STOMP protocol specifies and suggests some headers and also allows broker specific headers.\n   *\n   * `body` must be String.\n   * You will need to covert the payload to string in case it is not string (e.g. JSON).\n   *\n   * To send a binary message body use binaryBody parameter. It should be a\n   * [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array).\n   * Sometimes brokers may not support binary frames out of the box.\n   * Please check your broker documentation.\n   *\n   * `content-length` header is automatically added to the STOMP Frame sent to the broker.\n   * Set `skipContentLengthHeader` to indicate that `content-length` header should not be added.\n   * For binary messages `content-length` header is always added.\n   *\n   * Caution: The broker will, most likely, report an error and disconnect if message body has NULL octet(s)\n   * and `content-length` header is missing.\n   *\n   * The message will get locally queued if the STOMP broker is not connected. It will attempt to\n   * publish queued messages as soon as the broker gets connected.\n   * If you do not want that behavior,\n   * please set [retryIfDisconnected]{@link IRxStompPublishParams#retryIfDisconnected} to `false`\n   * in the parameters.\n   * When `false`, this function will raise an error if message could not be sent immediately.\n   *\n   * Maps to: [Client#publish]{@link Client#publish}\n   *\n   * See: {@link IRxStompPublishParams} and {@link IPublishParams}\n   *\n   * ```javascript\n   *        rxStomp.publish({destination: \"/queue/test\", headers: {priority: 9}, body: \"Hello, STOMP\"});\n   *\n   *        // Only destination is mandatory parameter\n   *        rxStomp.publish({destination: \"/queue/test\", body: \"Hello, STOMP\"});\n   *\n   *        // Skip content-length header in the frame to the broker\n   *        rxStomp.publish({\"/queue/test\", body: \"Hello, STOMP\", skipContentLengthHeader: true});\n   *\n   *        var binaryData = generateBinaryData(); // This need to be of type Uint8Array\n   *        // setting content-type header is not mandatory, however a good practice\n   *        rxStomp.publish({destination: '/topic/special', binaryBody: binaryData,\n   *                         headers: {'content-type': 'application/octet-stream'}});\n   * ```\n   */\n\n\n  publish(parameters) {\n    // retry behaviour is defaulted to true\n    const shouldRetry = parameters.retryIfDisconnected == null ? true : parameters.retryIfDisconnected;\n\n    if (this.connected()) {\n      this._stompClient.publish(parameters);\n    } else if (shouldRetry) {\n      this._debug(`Not connected, queueing`);\n\n      this._queuedMessages.push(parameters);\n    } else {\n      throw new Error('Cannot publish while broker is not connected');\n    }\n  }\n  /** It will send queued messages. */\n\n\n  _sendQueuedMessages() {\n    const queuedMessages = this._queuedMessages;\n    this._queuedMessages = [];\n\n    if (queuedMessages.length === 0) {\n      return;\n    }\n\n    this._debug(`Will try sending  ${queuedMessages.length} queued message(s)`);\n\n    for (const queuedMessage of queuedMessages) {\n      this._debug(`Attempting to send ${queuedMessage}`);\n\n      this.publish(queuedMessage);\n    }\n  }\n\n  watch(opts, headers = {}) {\n    const defaults = {\n      subHeaders: {},\n      unsubHeaders: {},\n      subscribeOnlyOnce: false\n    };\n    let params;\n\n    if (typeof opts === 'string') {\n      params = Object.assign({}, defaults, {\n        destination: opts,\n        subHeaders: headers\n      });\n    } else {\n      params = Object.assign({}, defaults, opts);\n    }\n    /* Well the logic is complicated but works beautifully. RxJS is indeed wonderful.\n     *\n     * We need to activate the underlying subscription immediately if Stomp is connected. If not it should\n     * subscribe when it gets next connected. Further it should re establish the subscription whenever Stomp\n     * successfully reconnects.\n     *\n     * Actual implementation is simple, we filter the BehaviourSubject 'state' so that we can trigger whenever Stomp is\n     * connected. Since 'state' is a BehaviourSubject, if Stomp is already connected, it will immediately trigger.\n     *\n     * The observable that we return to caller remains same across all reconnects, so no special handling needed at\n     * the message subscriber.\n     */\n\n\n    this._debug(`Request to subscribe ${params.destination}`);\n\n    const coldObservable = Observable.create(messages => {\n      /*\n       * These variables will be used as part of the closure and work their magic during unsubscribe\n       */\n      let stompSubscription; // Stomp\n\n      let stompConnectedSubscription; // RxJS\n\n      let connectedPre$ = this._connectedPre$;\n\n      if (params.subscribeOnlyOnce) {\n        connectedPre$ = connectedPre$.pipe(take(1));\n      }\n\n      stompConnectedSubscription = connectedPre$.subscribe(() => {\n        this._debug(`Will subscribe to ${params.destination}`);\n\n        let subHeaders = params.subHeaders;\n\n        if (typeof subHeaders === 'function') {\n          subHeaders = subHeaders();\n        }\n\n        stompSubscription = this._stompClient.subscribe(params.destination, message => {\n          messages.next(message);\n        }, subHeaders);\n      });\n      return () => {\n        /* cleanup function, will be called when no subscribers are left */\n        this._debug(`Stop watching connection state (for ${params.destination})`);\n\n        stompConnectedSubscription.unsubscribe();\n\n        if (this.connected()) {\n          this._debug(`Will unsubscribe from ${params.destination} at Stomp`);\n\n          let unsubHeaders = params.unsubHeaders;\n\n          if (typeof unsubHeaders === 'function') {\n            unsubHeaders = unsubHeaders();\n          }\n\n          stompSubscription.unsubscribe(unsubHeaders);\n        } else {\n          this._debug(`Stomp not connected, no need to unsubscribe from ${params.destination} at Stomp`);\n        }\n      };\n    });\n    /**\n     * Important - convert it to hot Observable - otherwise, if the user code subscribes\n     * to this observable twice, it will subscribe twice to Stomp broker. (This was happening in the current example).\n     * A long but good explanatory article at https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339\n     */\n\n    return coldObservable.pipe(share());\n  }\n  /**\n   * STOMP brokers may carry out operation asynchronously and allow requesting for acknowledgement.\n   * To request an acknowledgement, a `receipt` header needs to be sent with the actual request.\n   * The value (say receipt-id) for this header needs to be unique for each use. Typically a sequence, a UUID, a\n   * random number or a combination may be used.\n   *\n   * A complaint broker will send a RECEIPT frame when an operation has actually been completed.\n   * The operation needs to be matched based in the value of the receipt-id.\n   *\n   * This method allow watching for a receipt and invoke the callback\n   * when corresponding receipt has been received.\n   *\n   * The actual {@link Frame}\n   * will be passed as parameter to the callback.\n   *\n   * Example:\n   * ```javascript\n   *        // Publishing with acknowledgement\n   *        let receiptId = randomText();\n   *\n   *        rxStomp.watchForReceipt(receiptId, function() {\n   *          // Will be called after server acknowledges\n   *        });\n   *        rxStomp.publish({destination: '/topic/special', headers: {receipt: receiptId}, body: msg});\n   * ```\n   *\n   * Maps to: [Client#watchForReceipt]{@link Client#watchForReceipt}\n   */\n\n\n  watchForReceipt(receiptId, callback) {\n    this._stompClient.watchForReceipt(receiptId, callback);\n  }\n\n  _changeState(state) {\n    this._connectionStatePre$.next(state);\n\n    this.connectionState$.next(state);\n  }\n\n}","map":{"version":3,"sources":["../src/rx-stomp.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BehaviorSubject, Observable, Subject, } from 'rxjs';\nimport { filter, share, take } from 'rxjs/operators';\nimport { Client, } from '@stomp/stompjs';\nimport { RxStompState } from './rx-stomp-state';\n/**\n * This is the main Stomp Client.\n * Typically you will create an instance of this to connect to the STOMP broker.\n *\n * This wraps [@stomp/stompjs]{@link https://github.com/stomp-js/stompjs}\n * {@link Client} class.\n *\n * The key difference is that it exposes operations as RxJS Observables.\n * For example when a STOMP endpoint is subscribed it returns an Observable\n * that will stream all received messages.\n *\n * With exception of beforeConnect, functionality related to all callbacks in\n * [@stomp/stompjs Client]{@link Client}\n * is exposed as Observables/Subjects/BehaviorSubjects.\n *\n * RxStomp also tries to transparently handle connection failures.\n *\n * Part of `@stomp/rx-stomp`\n */\nexport class RxStomp {\n    /**\n     * Constructor\n     */\n    constructor() {\n        /**\n         * Internal array to hold locally queued messages when STOMP broker is not connected.\n         */\n        this._queuedMessages = [];\n        this._stompClient = new Client();\n        const noOp = () => { };\n        // Before connect is no op by default\n        this._beforeConnect = noOp;\n        // debug is no-op by default\n        this._debug = noOp;\n        // Initial state is CLOSED\n        this._connectionStatePre$ = new BehaviorSubject(RxStompState.CLOSED);\n        this._connectedPre$ = this._connectionStatePre$.pipe(filter((currentState) => {\n            return currentState === RxStompState.OPEN;\n        }));\n        // Initial state is CLOSED\n        this.connectionState$ = new BehaviorSubject(RxStompState.CLOSED);\n        this.connected$ = this.connectionState$.pipe(filter((currentState) => {\n            return currentState === RxStompState.OPEN;\n        }));\n        // Setup sending queuedMessages\n        this.connected$.subscribe(() => {\n            this._sendQueuedMessages();\n        });\n        this._serverHeadersBehaviourSubject$ = new BehaviorSubject(null);\n        this.serverHeaders$ = this._serverHeadersBehaviourSubject$.pipe(filter((headers) => {\n            return headers !== null;\n        }));\n        this.stompErrors$ = new Subject();\n        this.unhandledMessage$ = new Subject();\n        this.unhandledReceipts$ = new Subject();\n        this.unhandledFrame$ = new Subject();\n        this.webSocketErrors$ = new Subject();\n    }\n    /**\n     * Instance of actual\n     * [@stomp/stompjs]{@link https://github.com/stomp-js/stompjs}\n     * {@link Client}.\n     *\n     * **Be careful in calling methods on it directly - you may get unintended consequences.**\n     */\n    get stompClient() {\n        return this._stompClient;\n    }\n    /**\n     * Set configuration. This method may be called multiple times.\n     * Each call will add to the existing configuration.\n     *\n     * Example:\n     *\n     * ```javascript\n     *        const rxStomp = new RxStomp();\n     *        rxStomp.configure({\n     *          brokerURL: 'ws://127.0.0.1:15674/ws',\n     *          connectHeaders: {\n     *            login: 'guest',\n     *            passcode: 'guest'\n     *          },\n     *          heartbeatIncoming: 0,\n     *          heartbeatOutgoing: 20000,\n     *          reconnectDelay: 200,\n     *          debug: (msg: string): void => {\n     *            console.log(new Date(), msg);\n     *          }\n     *        });\n     *        rxStomp.activate();\n     * ```\n     *\n     * Maps to: [Client#configure]{@link Client#configure}\n     */\n    configure(rxStompConfig) {\n        const stompConfig = Object.assign({}, rxStompConfig);\n        if (stompConfig.beforeConnect) {\n            this._beforeConnect = stompConfig.beforeConnect;\n            delete stompConfig.beforeConnect;\n        }\n        // RxStompConfig has subset of StompConfig fields\n        this._stompClient.configure(stompConfig);\n        if (stompConfig.debug) {\n            this._debug = stompConfig.debug;\n        }\n    }\n    /**\n     * Initiate the connection with the broker.\n     * If the connection breaks, as per [RxStompConfig#reconnectDelay]{@link RxStompConfig#reconnectDelay},\n     * it will keep trying to reconnect.\n     *\n     * Call [RxStomp#deactivate]{@link RxStomp#deactivate} to disconnect and stop reconnection attempts.\n     *\n     * Maps to: [Client#activate]{@link Client#activate}\n     */\n    activate() {\n        this._stompClient.configure({\n            beforeConnect: () => __awaiter(this, void 0, void 0, function* () {\n                this._changeState(RxStompState.CONNECTING);\n                // Call handler\n                yield this._beforeConnect(this);\n            }),\n            onConnect: (frame) => {\n                this._serverHeadersBehaviourSubject$.next(frame.headers);\n                // Indicate our connected state to observers\n                this._changeState(RxStompState.OPEN);\n            },\n            onStompError: (frame) => {\n                // Trigger the frame subject\n                this.stompErrors$.next(frame);\n            },\n            onWebSocketClose: () => {\n                this._changeState(RxStompState.CLOSED);\n            },\n            onUnhandledMessage: (message) => {\n                this.unhandledMessage$.next(message);\n            },\n            onUnhandledReceipt: (frame) => {\n                this.unhandledReceipts$.next(frame);\n            },\n            onUnhandledFrame: (frame) => {\n                this.unhandledFrame$.next(frame);\n            },\n            onWebSocketError: (evt) => {\n                this.webSocketErrors$.next(evt);\n            },\n        });\n        // Attempt connection\n        this._stompClient.activate();\n    }\n    /**\n     * Disconnect if connected and stop auto reconnect loop.\n     * Appropriate callbacks will be invoked if underlying STOMP connection was connected.\n     *\n     * To reactivate you can call [RxStomp#activate]{@link RxStomp#activate}.\n     *\n     * Maps to: [Client#deactivate]{@link Client#deactivate}\n     */\n    deactivate() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._changeState(RxStompState.CLOSING);\n            // The promise will be resolved immediately if there are no active connection\n            // otherwise, after it has successfully disconnected.\n            yield this._stompClient.deactivate();\n            this._changeState(RxStompState.CLOSED);\n        });\n    }\n    /**\n     * It will return `true` if STOMP broker is connected and `false` otherwise.\n     */\n    connected() {\n        return this.connectionState$.getValue() === RxStompState.OPEN;\n    }\n    /**\n     * If the client is active (connected or going to reconnect).\n     *\n     *  Maps to: [Client#active]{@link Client#active}\n     */\n    get active() {\n        return this.stompClient.active;\n    }\n    /**\n     * Send a message to a named destination. Refer to your STOMP broker documentation for types\n     * and naming of destinations.\n     *\n     * STOMP protocol specifies and suggests some headers and also allows broker specific headers.\n     *\n     * `body` must be String.\n     * You will need to covert the payload to string in case it is not string (e.g. JSON).\n     *\n     * To send a binary message body use binaryBody parameter. It should be a\n     * [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array).\n     * Sometimes brokers may not support binary frames out of the box.\n     * Please check your broker documentation.\n     *\n     * `content-length` header is automatically added to the STOMP Frame sent to the broker.\n     * Set `skipContentLengthHeader` to indicate that `content-length` header should not be added.\n     * For binary messages `content-length` header is always added.\n     *\n     * Caution: The broker will, most likely, report an error and disconnect if message body has NULL octet(s)\n     * and `content-length` header is missing.\n     *\n     * The message will get locally queued if the STOMP broker is not connected. It will attempt to\n     * publish queued messages as soon as the broker gets connected.\n     * If you do not want that behavior,\n     * please set [retryIfDisconnected]{@link IRxStompPublishParams#retryIfDisconnected} to `false`\n     * in the parameters.\n     * When `false`, this function will raise an error if message could not be sent immediately.\n     *\n     * Maps to: [Client#publish]{@link Client#publish}\n     *\n     * See: {@link IRxStompPublishParams} and {@link IPublishParams}\n     *\n     * ```javascript\n     *        rxStomp.publish({destination: \"/queue/test\", headers: {priority: 9}, body: \"Hello, STOMP\"});\n     *\n     *        // Only destination is mandatory parameter\n     *        rxStomp.publish({destination: \"/queue/test\", body: \"Hello, STOMP\"});\n     *\n     *        // Skip content-length header in the frame to the broker\n     *        rxStomp.publish({\"/queue/test\", body: \"Hello, STOMP\", skipContentLengthHeader: true});\n     *\n     *        var binaryData = generateBinaryData(); // This need to be of type Uint8Array\n     *        // setting content-type header is not mandatory, however a good practice\n     *        rxStomp.publish({destination: '/topic/special', binaryBody: binaryData,\n     *                         headers: {'content-type': 'application/octet-stream'}});\n     * ```\n     */\n    publish(parameters) {\n        // retry behaviour is defaulted to true\n        const shouldRetry = parameters.retryIfDisconnected == null\n            ? true\n            : parameters.retryIfDisconnected;\n        if (this.connected()) {\n            this._stompClient.publish(parameters);\n        }\n        else if (shouldRetry) {\n            this._debug(`Not connected, queueing`);\n            this._queuedMessages.push(parameters);\n        }\n        else {\n            throw new Error('Cannot publish while broker is not connected');\n        }\n    }\n    /** It will send queued messages. */\n    _sendQueuedMessages() {\n        const queuedMessages = this._queuedMessages;\n        this._queuedMessages = [];\n        if (queuedMessages.length === 0) {\n            return;\n        }\n        this._debug(`Will try sending  ${queuedMessages.length} queued message(s)`);\n        for (const queuedMessage of queuedMessages) {\n            this._debug(`Attempting to send ${queuedMessage}`);\n            this.publish(queuedMessage);\n        }\n    }\n    watch(opts, headers = {}) {\n        const defaults = {\n            subHeaders: {},\n            unsubHeaders: {},\n            subscribeOnlyOnce: false,\n        };\n        let params;\n        if (typeof opts === 'string') {\n            params = Object.assign({}, defaults, {\n                destination: opts,\n                subHeaders: headers,\n            });\n        }\n        else {\n            params = Object.assign({}, defaults, opts);\n        }\n        /* Well the logic is complicated but works beautifully. RxJS is indeed wonderful.\n         *\n         * We need to activate the underlying subscription immediately if Stomp is connected. If not it should\n         * subscribe when it gets next connected. Further it should re establish the subscription whenever Stomp\n         * successfully reconnects.\n         *\n         * Actual implementation is simple, we filter the BehaviourSubject 'state' so that we can trigger whenever Stomp is\n         * connected. Since 'state' is a BehaviourSubject, if Stomp is already connected, it will immediately trigger.\n         *\n         * The observable that we return to caller remains same across all reconnects, so no special handling needed at\n         * the message subscriber.\n         */\n        this._debug(`Request to subscribe ${params.destination}`);\n        const coldObservable = Observable.create((messages) => {\n            /*\n             * These variables will be used as part of the closure and work their magic during unsubscribe\n             */\n            let stompSubscription; // Stomp\n            let stompConnectedSubscription; // RxJS\n            let connectedPre$ = this._connectedPre$;\n            if (params.subscribeOnlyOnce) {\n                connectedPre$ = connectedPre$.pipe(take(1));\n            }\n            stompConnectedSubscription = connectedPre$.subscribe(() => {\n                this._debug(`Will subscribe to ${params.destination}`);\n                let subHeaders = params.subHeaders;\n                if (typeof subHeaders === 'function') {\n                    subHeaders = subHeaders();\n                }\n                stompSubscription = this._stompClient.subscribe(params.destination, (message) => {\n                    messages.next(message);\n                }, subHeaders);\n            });\n            return () => {\n                /* cleanup function, will be called when no subscribers are left */\n                this._debug(`Stop watching connection state (for ${params.destination})`);\n                stompConnectedSubscription.unsubscribe();\n                if (this.connected()) {\n                    this._debug(`Will unsubscribe from ${params.destination} at Stomp`);\n                    let unsubHeaders = params.unsubHeaders;\n                    if (typeof unsubHeaders === 'function') {\n                        unsubHeaders = unsubHeaders();\n                    }\n                    stompSubscription.unsubscribe(unsubHeaders);\n                }\n                else {\n                    this._debug(`Stomp not connected, no need to unsubscribe from ${params.destination} at Stomp`);\n                }\n            };\n        });\n        /**\n         * Important - convert it to hot Observable - otherwise, if the user code subscribes\n         * to this observable twice, it will subscribe twice to Stomp broker. (This was happening in the current example).\n         * A long but good explanatory article at https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339\n         */\n        return coldObservable.pipe(share());\n    }\n    /**\n     * STOMP brokers may carry out operation asynchronously and allow requesting for acknowledgement.\n     * To request an acknowledgement, a `receipt` header needs to be sent with the actual request.\n     * The value (say receipt-id) for this header needs to be unique for each use. Typically a sequence, a UUID, a\n     * random number or a combination may be used.\n     *\n     * A complaint broker will send a RECEIPT frame when an operation has actually been completed.\n     * The operation needs to be matched based in the value of the receipt-id.\n     *\n     * This method allow watching for a receipt and invoke the callback\n     * when corresponding receipt has been received.\n     *\n     * The actual {@link Frame}\n     * will be passed as parameter to the callback.\n     *\n     * Example:\n     * ```javascript\n     *        // Publishing with acknowledgement\n     *        let receiptId = randomText();\n     *\n     *        rxStomp.watchForReceipt(receiptId, function() {\n     *          // Will be called after server acknowledges\n     *        });\n     *        rxStomp.publish({destination: '/topic/special', headers: {receipt: receiptId}, body: msg});\n     * ```\n     *\n     * Maps to: [Client#watchForReceipt]{@link Client#watchForReceipt}\n     */\n    watchForReceipt(receiptId, callback) {\n        this._stompClient.watchForReceipt(receiptId, callback);\n    }\n    _changeState(state) {\n        this._connectionStatePre$.next(state);\n        this.connectionState$.next(state);\n    }\n}\n//# sourceMappingURL=rx-stomp.js.map"]},"metadata":{},"sourceType":"module"}