{"ast":null,"code":"import { Observable } from 'rxjs';\nimport { filter, first } from 'rxjs/operators';\nimport { UUID } from 'angular2-uuid';\n/**\n * An implementation of Remote Procedure Call (RPC) using messaging.\n *\n * Please see the [guide](/guide/rx-stomp/ng2-stompjs/remote-procedure-call.html) for details.\n *\n * Part of `@stomp/rx-stomp`\n */\n\nexport class RxStompRPC {\n  /**\n   * Create an instance, see the [guide](/guide/rx-stomp/ng2-stompjs/remote-procedure-call.html) for details.\n   */\n  constructor(rxStomp, stompRPCConfig) {\n    this.rxStomp = rxStomp;\n    this.stompRPCConfig = stompRPCConfig;\n    this._replyQueueName = '/temp-queue/rpc-replies';\n\n    this._setupReplyQueue = () => {\n      return this.rxStomp.unhandledMessage$;\n    };\n\n    if (stompRPCConfig) {\n      if (stompRPCConfig.replyQueueName) {\n        this._replyQueueName = stompRPCConfig.replyQueueName;\n      }\n\n      if (stompRPCConfig.setupReplyQueue) {\n        this._setupReplyQueue = stompRPCConfig.setupReplyQueue;\n      }\n    }\n  }\n  /**\n   * Make an RPC request.\n   * See the [guide](/guide/rx-stomp/ng2-stompjs/remote-procedure-call.html) for example.\n   *\n   * It is a simple wrapper around [RxStompRPC#stream]{@link RxStompRPC#stream}.\n   */\n\n\n  rpc(params) {\n    // We know there will be only one message in reply\n    return this.stream(params).pipe(first());\n  }\n  /**\n   * Make an RPC stream request. See the [guide](/guide/rx-stomp/ng2-stompjs/remote-procedure-call.html).\n   *\n   * Note: This call internally takes care of generating a correlation id,\n   * however, if `correlation-id` is passed via `headers`, that will be used instead.\n   */\n\n\n  stream(params) {\n    const headers = Object.assign({}, params.headers || {});\n    const {\n      destination,\n      body,\n      binaryBody\n    } = params;\n\n    if (!this._repliesObservable) {\n      this._repliesObservable = this._setupReplyQueue(this._replyQueueName, this.rxStomp);\n    }\n\n    return Observable.create(rpcObserver => {\n      let defaultMessagesSubscription;\n      const correlationId = headers['correlation-id'] || UUID.UUID();\n      defaultMessagesSubscription = this._repliesObservable.pipe(filter(message => {\n        return message.headers['correlation-id'] === correlationId;\n      })).subscribe(message => {\n        rpcObserver.next(message);\n      }); // send an RPC request\n\n      headers['reply-to'] = this._replyQueueName;\n      headers['correlation-id'] = correlationId;\n      this.rxStomp.publish({\n        destination,\n        body,\n        binaryBody,\n        headers\n      });\n      return () => {\n        // Cleanup\n        defaultMessagesSubscription.unsubscribe();\n      };\n    });\n  }\n\n}","map":{"version":3,"sources":["../src/rx-stomp-rpc.ts"],"names":[],"mappings":"AAAA,SAAS,UAAT,QAAmD,MAAnD;AACA,SAAS,MAAT,EAAiB,KAAjB,QAA8B,gBAA9B;AAEA,SAAS,IAAT,QAAqB,eAArB;AAOA;;;;;;AAMG;;AACH,OAAM,MAAO,UAAP,CAAiB;AASrB;;AAEG;AACH,EAAA,WAAA,CACU,OADV,EAEU,cAFV,EAE2C;AADjC,SAAA,OAAA,GAAA,OAAA;AACA,SAAA,cAAA,GAAA,cAAA;AAbF,SAAA,eAAA,GAAkB,yBAAlB;;AAEA,SAAA,gBAAA,GAA0C,MAAK;AACrD,aAAO,KAAK,OAAL,CAAa,iBAApB;AACD,KAFO;;AAaN,QAAI,cAAJ,EAAoB;AAClB,UAAI,cAAc,CAAC,cAAnB,EAAmC;AACjC,aAAK,eAAL,GAAuB,cAAc,CAAC,cAAtC;AACD;;AACD,UAAI,cAAc,CAAC,eAAnB,EAAoC;AAClC,aAAK,gBAAL,GAAwB,cAAc,CAAC,eAAvC;AACD;AACF;AACF;AAED;;;;;AAKG;;;AACI,EAAA,GAAG,CAAC,MAAD,EAAsB;AAC9B;AACA,WAAO,KAAK,MAAL,CAAY,MAAZ,EAAoB,IAApB,CAAyB,KAAK,EAA9B,CAAP;AACD;AAED;;;;;AAKG;;;AACI,EAAA,MAAM,CAAC,MAAD,EAAsB;AACjC,UAAM,OAAO,GAAkB,MAAc,CAAC,MAAf,CAC7B,EAD6B,EAE7B,MAAM,CAAC,OAAP,IAAkB,EAFW,CAA/B;AAIA,UAAM;AAAE,MAAA,WAAF;AAAe,MAAA,IAAf;AAAqB,MAAA;AAArB,QAAoC,MAA1C;;AAEA,QAAI,CAAC,KAAK,kBAAV,EAA8B;AAC5B,WAAK,kBAAL,GAA0B,KAAK,gBAAL,CACxB,KAAK,eADmB,EAExB,KAAK,OAFmB,CAA1B;AAID;;AAED,WAAO,UAAU,CAAC,MAAX,CAAmB,WAAD,IAAoC;AAC3D,UAAI,2BAAJ;AAEA,YAAM,aAAa,GAAG,OAAO,CAAC,gBAAD,CAAP,IAA6B,IAAI,CAAC,IAAL,EAAnD;AAEA,MAAA,2BAA2B,GAAG,KAAK,kBAAL,CAC3B,IAD2B,CAE1B,MAAM,CAAE,OAAD,IAAsB;AAC3B,eAAO,OAAO,CAAC,OAAR,CAAgB,gBAAhB,MAAsC,aAA7C;AACD,OAFK,CAFoB,EAM3B,SAN2B,CAMhB,OAAD,IAAsB;AAC/B,QAAA,WAAW,CAAC,IAAZ,CAAiB,OAAjB;AACD,OAR2B,CAA9B,CAL2D,CAe3D;;AACA,MAAA,OAAO,CAAC,UAAD,CAAP,GAAsB,KAAK,eAA3B;AACA,MAAA,OAAO,CAAC,gBAAD,CAAP,GAA4B,aAA5B;AAEA,WAAK,OAAL,CAAa,OAAb,CAAqB;AAAE,QAAA,WAAF;AAAe,QAAA,IAAf;AAAqB,QAAA,UAArB;AAAiC,QAAA;AAAjC,OAArB;AAEA,aAAO,MAAK;AACV;AACA,QAAA,2BAA2B,CAAC,WAA5B;AACD,OAHD;AAID,KAzBM,CAAP;AA0BD;;AAnFoB","sourceRoot":"","sourcesContent":["import { Observable } from 'rxjs';\nimport { filter, first } from 'rxjs/operators';\nimport { UUID } from 'angular2-uuid';\n/**\n * An implementation of Remote Procedure Call (RPC) using messaging.\n *\n * Please see the [guide](/guide/rx-stomp/ng2-stompjs/remote-procedure-call.html) for details.\n *\n * Part of `@stomp/rx-stomp`\n */\nexport class RxStompRPC {\n    /**\n     * Create an instance, see the [guide](/guide/rx-stomp/ng2-stompjs/remote-procedure-call.html) for details.\n     */\n    constructor(rxStomp, stompRPCConfig) {\n        this.rxStomp = rxStomp;\n        this.stompRPCConfig = stompRPCConfig;\n        this._replyQueueName = '/temp-queue/rpc-replies';\n        this._setupReplyQueue = () => {\n            return this.rxStomp.unhandledMessage$;\n        };\n        if (stompRPCConfig) {\n            if (stompRPCConfig.replyQueueName) {\n                this._replyQueueName = stompRPCConfig.replyQueueName;\n            }\n            if (stompRPCConfig.setupReplyQueue) {\n                this._setupReplyQueue = stompRPCConfig.setupReplyQueue;\n            }\n        }\n    }\n    /**\n     * Make an RPC request.\n     * See the [guide](/guide/rx-stomp/ng2-stompjs/remote-procedure-call.html) for example.\n     *\n     * It is a simple wrapper around [RxStompRPC#stream]{@link RxStompRPC#stream}.\n     */\n    rpc(params) {\n        // We know there will be only one message in reply\n        return this.stream(params).pipe(first());\n    }\n    /**\n     * Make an RPC stream request. See the [guide](/guide/rx-stomp/ng2-stompjs/remote-procedure-call.html).\n     *\n     * Note: This call internally takes care of generating a correlation id,\n     * however, if `correlation-id` is passed via `headers`, that will be used instead.\n     */\n    stream(params) {\n        const headers = Object.assign({}, params.headers || {});\n        const { destination, body, binaryBody } = params;\n        if (!this._repliesObservable) {\n            this._repliesObservable = this._setupReplyQueue(this._replyQueueName, this.rxStomp);\n        }\n        return Observable.create((rpcObserver) => {\n            let defaultMessagesSubscription;\n            const correlationId = headers['correlation-id'] || UUID.UUID();\n            defaultMessagesSubscription = this._repliesObservable\n                .pipe(filter((message) => {\n                return message.headers['correlation-id'] === correlationId;\n            }))\n                .subscribe((message) => {\n                rpcObserver.next(message);\n            });\n            // send an RPC request\n            headers['reply-to'] = this._replyQueueName;\n            headers['correlation-id'] = correlationId;\n            this.rxStomp.publish({ destination, body, binaryBody, headers });\n            return () => {\n                // Cleanup\n                defaultMessagesSubscription.unsubscribe();\n            };\n        });\n    }\n}\n//# sourceMappingURL=rx-stomp-rpc.js.map"]},"metadata":{},"sourceType":"module"}